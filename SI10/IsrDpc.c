/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
PURPOSE.

Module Name:

IsrDpc.c

Abstract:

Contains routines related to interrupt and dpc handling.

Environment:

Kernel mode

--*/

#include "precomp.h"

#define INTR_TYPE_NONE                  0              // Interrupt identifiers
#define INTR_TYPE_LOCAL_1               (1 << 0)
#define INTR_TYPE_LOCAL_2               (1 << 1)
#define INTR_TYPE_PCI_ABORT             (1 << 2)
#define INTR_TYPE_DOORBELL              (1 << 3)
#define INTR_TYPE_OUTBOUND_POST         (1 << 4)
#define INTR_TYPE_DMA_0                 (1 << 5)
#define INTR_TYPE_DMA_1                 (1 << 6)
#define INTR_TYPE_SOFTWARE              (1 << 7)

ULONG	g_ulIsrCount;

//#include "IsrDpc.tmh"

NTSTATUS
PLxInterruptCreate(
	IN PDEVICE_EXTENSION DevExt
)
/*++
Routine Description:

Configure and create the WDFINTERRUPT object.
This routine is called by EvtDeviceAdd callback.

Arguments:

DevExt      Pointer to our DEVICE_EXTENSION

Return Value:

NTSTATUS code

--*/
{
	NTSTATUS                    status;
	WDF_INTERRUPT_CONFIG        InterruptConfig;

	WDF_INTERRUPT_CONFIG_INIT(&InterruptConfig,
		PLxEvtInterruptIsr,
		PLxEvtInterruptDpc);

	InterruptConfig.EvtInterruptEnable = PLxEvtInterruptEnable;
	InterruptConfig.EvtInterruptDisable = PLxEvtInterruptDisable;

	// JOHNR: Enable testing of the DpcForIsr Synchronization
	InterruptConfig.AutomaticSerialization = FALSE;

	//
	// Unlike WDM, framework driver should create interrupt object in EvtDeviceAdd and
	// let the framework do the resource parsing and registration of ISR with the kernel.
	// Framework connects the interrupt after invoking the EvtDeviceD0Entry callback
	// and disconnect before invoking EvtDeviceD0Exit. EvtInterruptEnable is called after
	// the interrupt interrupt is connected and EvtInterruptDisable before the interrupt is
	// disconnected.
	//
	KdPrint(("\n	WdfInterruptCreate\n"));
	g_ulIsrCount = 0;

	status = WdfInterruptCreate(DevExt->Device,
		&InterruptConfig,
		WDF_NO_OBJECT_ATTRIBUTES,
		&DevExt->Interrupt);

	if (!NT_SUCCESS(status)) {
		KdPrint((
			"WdfInterruptCreate failed: %!STATUS!", status));
	}

	return status;
}

BOOLEAN
PLxEvtInterruptIsr(
	IN WDFINTERRUPT Interrupt,
	IN ULONG        MessageID
)
/*++
Routine Description:

Interrupt handler for this driver. Called at DIRQL level when the
device or another device sharing the same interrupt line asserts
the interrupt. The driver first checks the device to make sure whether
this interrupt is generated by its device and if so clear the interrupt
register to disable further generation of interrupts and queue a
DPC to do other I/O work related to interrupt - such as reading
the device memory, starting a DMA transaction, coping it to
the request buffer and completing the request, etc.

Arguments:

Interupt   - Handle to WDFINTERRUPT Object for this device.
MessageID  - MSI message ID (always 0 in this configuration)

Return Value:

TRUE   --  This device generated the interrupt.
FALSE  --  This device did not generated this interrupt.

--*/
{
	PDEVICE_EXTENSION   devExt;
	BOOLEAN             isRecognized = FALSE;
	
	union {
		INT_CSR bits;
		ULONG   ulong;
	} intCsr;

	UNREFERENCED_PARAMETER(MessageID);

	//KdPrint((
	//            "--> PLxInterruptHandler");

	devExt = PLxGetDeviceContext(WdfInterruptGetDevice(Interrupt));

	// Read the Interrupt CSR register (INTCSR)
	PUINT8 cardAddress = (PUINT8)devExt->BarVirtualAddress[0] + PCI9030_INT_CTRL_STAT;

	intCsr.ulong = READ_REGISTER_ULONG((PULONG)cardAddress);

	if (intCsr.ulong == 0xFFFFFFFF)
		return FALSE;

	// Check for master PCI interrupt enable
	if (intCsr.bits.PCIEnable == 0)
		return FALSE;

	int InterruptSource = INTR_TYPE_NONE;

	if(intCsr.bits.LocalInt1Status && intCsr.bits.LocalInt1Enable)
	{
		InterruptSource |= INTR_TYPE_LOCAL_1;
	}

	if (intCsr.bits.LocalInt2Status && intCsr.bits.LocalInt2Enable)
	{
		InterruptSource |= INTR_TYPE_LOCAL_2;
	}

	if (intCsr.bits.SoftwareInterrupt)
	{
		InterruptSource |= INTR_TYPE_SOFTWARE;
	}

	if (InterruptSource == INTR_TYPE_NONE)
		return FALSE;

	g_ulIsrCount++;

	isRecognized = TRUE;

	//Clear the SI10 PIC
	cardAddress = (PUINT8)devExt->BarVirtualAddress[2] + 0x1AC;
	devExt->SI10_IRQ_Source = READ_REGISTER_ULONG((PULONG)cardAddress);

	/*
	if (pdx->bUserShared == TRUE)
	{
		unsigned char OldIrql;
		KeRaiseIrql(31, &OldIrql);
		Si10Isr(pdx);
		KeLowerIrql(OldIrql);
	}
	*/

	// Mask the PCI Interrupt


	//
	// Is DMA channel 0 (Write-side) Active?
	//
	/*
	if (intCsr.bits.DmaChan0IntActive) {

		KdPrint((
			" Interrupt for DMA Channel 0 (write)"));

		devExt->IntCsr.bits.DmaChan0IntActive = TRUE;

		//
		// Clear this interrupt.
		//
		devExt->Dma0Csr.uchar =
			READ_REGISTER_UCHAR((PUCHAR)&devExt->Regs->Dma0_Csr);

		devExt->Dma0Csr.bits.Clear = TRUE;

		WRITE_REGISTER_UCHAR((PUCHAR)&devExt->Regs->Dma0_Csr,
			devExt->Dma0Csr.uchar);

		isRecognized = TRUE;
	}

	//
	// Is DMA channel 1 (Read-side) Active?
	//
	if (intCsr.bits.DmaChan1IntActive) {

		KdPrint((
			" Interrupt for DMA Channel 1 (read)"));

		devExt->IntCsr.bits.DmaChan1IntActive = TRUE;

		//
		// Clear this interrupt.
		//
		devExt->Dma1Csr.uchar =
			READ_REGISTER_UCHAR((PUCHAR)&devExt->Regs->Dma1_Csr);

		devExt->Dma1Csr.bits.Clear = TRUE;

		WRITE_REGISTER_UCHAR((PUCHAR)&devExt->Regs->Dma1_Csr,
			devExt->Dma1Csr.uchar);

		isRecognized = TRUE;
	}
	*/
	/*
	if ((isRecognized) &&
		((devExt->Dma0Csr.bits.Done) ||
		(devExt->Dma1Csr.bits.Done))) {
		WdfInterruptQueueDpcForIsr(devExt->Interrupt);
	}*/
	if (isRecognized) {
		WdfInterruptQueueDpcForIsr(devExt->Interrupt);
	}


	//KdPrint((
	//            "<-- PLxInterruptHandler");

	return isRecognized;
}

_Use_decl_annotations_
VOID
PLxEvtInterruptDpc(
	WDFINTERRUPT Interrupt,
	WDFOBJECT    Device
)
/*++

Routine Description:

DPC callback for ISR. Please note that on a multiprocessor system,
you could have more than one DPCs running simulataneously on
multiple processors. So if you are accesing any global resources
make sure to synchrnonize the accesses with a spinlock.

Arguments:

Interupt  - Handle to WDFINTERRUPT Object for this device.
Device    - WDFDEVICE object passed to InterruptCreate

Return Value:

--*/
{
	NTSTATUS            status;
	WDFDMATRANSACTION   dmaTransaction;
	PDEVICE_EXTENSION   devExt;
	BOOLEAN             writeInterrupt = FALSE;
	BOOLEAN             readInterrupt = FALSE;

	UNREFERENCED_PARAMETER(Device);
	UNREFERENCED_PARAMETER(writeInterrupt);


//	KdPrint(( "--> EvtInterruptDpc"));

	devExt = PLxGetDeviceContext(WdfInterruptGetDevice(Interrupt));
	/*
	WdfInterruptAcquireLock(Interrupt);

	
	//
	// Acquire this device's InterruptSpinLock.
	//


	if ((devExt->IntCsr.bits.DmaChan0IntActive) &&
		(devExt->Dma0Csr.bits.Done)) {

		//
		// If Dma0 channel 0 (write) is interrupting and the
		//  Done bit is set in the Dma0 CSR,
		//  we're interrupting because a WRITE is complete.
		// Clear the done bit and channel interrupting bit from
		//  our copies...
		//
		devExt->IntCsr.bits.DmaChan0IntActive = FALSE;
		devExt->Dma0Csr.uchar = 0;

		writeInterrupt = TRUE;
	}

	if ((devExt->IntCsr.bits.DmaChan1IntActive) &&
		(devExt->Dma1Csr.bits.Done)) {

		//
		// If DMA channel 1 is interrupting and the
		//  DONE bit is set in the DMA1 control/status
		//  register, we're interrupting because a READ
		//  is complete.
		// Clear the done bit and channel interrupting bit from
		//  our copies...
		//
		devExt->IntCsr.bits.DmaChan1IntActive = FALSE;
		devExt->Dma0Csr.uchar = 0;

		readInterrupt = TRUE;
	}

	//
	// Release our interrupt spinlock
	//
	WdfInterruptReleaseLock(Interrupt);

	//
	// Did a Write DMA complete?
	//
	if (writeInterrupt) {

		BOOLEAN transactionComplete;

		//
		// Get the current Write DmaTransaction.
		//
		dmaTransaction = devExt->WriteDmaTransaction;

		//
		// Indicate this DMA operation has completed:
		// This may drive the transfer on the next packet if
		// there is still data to be transfered in the request.
		//
		transactionComplete = WdfDmaTransactionDmaCompleted(dmaTransaction,
			&status);

		if (transactionComplete) {
			//
			// Complete this DmaTransaction.
			//
			KdPrint((
				"Completing Write request in the DpcForIsr"));

			PLxWriteRequestComplete(dmaTransaction, status);

		}
	}
	*/
	//
	// Did a Read DMA complete?
	//
	if (readInterrupt) {

		BOOLEAN                transactionComplete;
		PDMA_TRANSFER_ELEMENT  dteVA;
		size_t                 length;

		//
		// Get the current Read DmaTransaction.
		//
		dmaTransaction = devExt->ReadDmaTransaction;

		//
		// Only on Read-side --
		//    Use "DMA Clear-Count Mode" to get complemetary
		//    transferred byte count.
		//
		length = WdfDmaTransactionGetCurrentDmaTransferLength(dmaTransaction);

		dteVA = (PDMA_TRANSFER_ELEMENT)devExt->ReadCommonBufferBase;

		while (dteVA->DescPtr.LastElement == FALSE) {
			length -= dteVA->TransferSize;
			dteVA++;
		}
		length -= dteVA->TransferSize;

		//
		// Indicate this DMA operation has completed:
		// This may drive the transfer on the next packet if
		// there is still data to be transfered in the request.
		//
		transactionComplete =
			WdfDmaTransactionDmaCompletedWithLength(dmaTransaction,
				length,
				&status);

		if (transactionComplete) {
			//
			// Complete this DmaTransaction.
			//
			KdPrint((
				"Completing Read request in the DpcForIsr"));

			PLxReadRequestComplete(dmaTransaction, status);

		}
	}
	if (devExt->pIntEvent) {
		KeSetEvent(devExt->pIntEvent, 0, FALSE);
	}

//	KdPrint(( "<-- EvtInterruptDpc"));

	return;
}

NTSTATUS
PLxEvtInterruptEnable(
	IN WDFINTERRUPT Interrupt,
	IN WDFDEVICE    Device
)
/*++

Routine Description:

Called by the framework at DIRQL immediately after registering the ISR with the kernel
by calling IoConnectInterrupt.

Return Value:

NTSTATUS
--*/
{
	PDEVICE_EXTENSION  devExt;

	union {
		INT_CSR   bits;
		ULONG     ulong;
	} intCSR;

# ifndef DBG 
	UNREFERENCED_PARAMETER(Device);
#endif

	KdPrint(("PLxEvtInterruptEnable: Interrupt 0x%p, Device 0x%p\n",Interrupt, Device));

	devExt = PLxGetDeviceContext(WdfInterruptGetDevice(Interrupt));

	PUINT8 cardAddress = (PUINT8)devExt->BarVirtualAddress[0] + PCI9030_INT_CTRL_STAT;

	intCSR.ulong = READ_REGISTER_ULONG((PULONG)cardAddress);
	KdPrint(("Interrupt mask 0x%x\n", intCSR.ulong));

	intCSR.bits.PCIEnable = TRUE;
	intCSR.bits.LocalInt1Enable = TRUE;
	intCSR.bits.LocalInt2Enable = TRUE;

	WRITE_REGISTER_ULONG((PULONG)cardAddress,	intCSR.ulong);
	KdPrint(("Interrupt mask 0x%x\n", intCSR.ulong));

	return STATUS_SUCCESS;
}

NTSTATUS
PLxEvtInterruptDisable(
	IN WDFINTERRUPT Interrupt,
	IN WDFDEVICE    Device
)
/*++

Routine Description:

Called by the framework at DIRQL before Deregistering the ISR with the kernel
by calling IoDisconnectInterrupt.

Return Value:

NTSTATUS
--*/
{
	PDEVICE_EXTENSION  devExt;

	union {
		INT_CSR   bits;
		ULONG     ulong;
	} intCSR;

# ifndef DBG 
	UNREFERENCED_PARAMETER(Device);
#endif
	KdPrint(("PLxEvtInterruptDisable: Interrupt 0x%p, Device 0x%p\n",	Interrupt, Device));

	devExt = PLxGetDeviceContext(WdfInterruptGetDevice(Interrupt));

	PUINT8 cardAddress = (PUINT8)devExt->BarVirtualAddress[0] + PCI9030_INT_CTRL_STAT;

	intCSR.ulong = READ_REGISTER_ULONG((PULONG)cardAddress);

	intCSR.bits.PCIEnable = FALSE;
	intCSR.bits.LocalInt1Enable = FALSE;
	intCSR.bits.LocalInt2Enable = FALSE;

	intCSR.ulong = 0;

	WRITE_REGISTER_ULONG((PULONG)cardAddress, intCSR.ulong);

	if (devExt->pIntEvent)
	{						// event already registered
		ObDereferenceObject(devExt->pIntEvent);
		devExt->pIntEvent = NULL;
	}						// event already registered


	return STATUS_SUCCESS;
}
